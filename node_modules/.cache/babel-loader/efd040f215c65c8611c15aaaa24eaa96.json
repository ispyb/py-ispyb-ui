{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport isPromise from './isPromise.js';\n/**\n * For TypeScript support: Remember to check and make sure\n * that `index.d.ts` is also up to date with the implementation.\n */\n\nexport var ActionType = {\n  Pending: 'PENDING',\n  Fulfilled: 'FULFILLED',\n  Rejected: 'REJECTED'\n};\n/**\n * Function: createPromise\n * Description: The main createPromise accepts a configuration\n * object and returns the middleware.\n */\n\nexport function createPromise() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultTypes = [ActionType.Pending, ActionType.Fulfilled, ActionType.Rejected];\n  var PROMISE_TYPE_SUFFIXES = config.promiseTypeSuffixes || defaultTypes;\n  var PROMISE_TYPE_DELIMITER = config.promiseTypeDelimiter || '_';\n  return function (ref) {\n    var dispatch = ref.dispatch;\n    return function (next) {\n      return function (action) {\n        /**\n         * Instantiate variables to hold:\n         * (1) the promise\n         * (2) the data for optimistic updates\n         */\n        var promise = void 0;\n        var data = void 0;\n        /**\n         * There are multiple ways to dispatch a promise. The first step is to\n         * determine if the promise is defined:\n         * (a) explicitly (action.payload.promise is the promise)\n         * (b) implicitly (action.payload is the promise)\n         * (c) as an async function (returns a promise when called)\n         *\n         * If the promise is not defined in one of these three ways, we don't do\n         * anything and move on to the next middleware in the middleware chain.\n         */\n        // Step 1a: Is there a payload?\n\n        if (action.payload) {\n          var PAYLOAD = action.payload; // Step 1.1: Is the promise implicitly defined?\n\n          if (isPromise(PAYLOAD)) {\n            promise = PAYLOAD;\n          } // Step 1.2: Is the promise explicitly defined?\n          else if (isPromise(PAYLOAD.promise)) {\n            promise = PAYLOAD.promise;\n            data = PAYLOAD.data;\n          } // Step 1.3: Is the promise returned by an async function?\n          else if (typeof PAYLOAD === 'function' || typeof PAYLOAD.promise === 'function') {\n            promise = PAYLOAD.promise ? PAYLOAD.promise() : PAYLOAD();\n            data = PAYLOAD.promise ? PAYLOAD.data : undefined; // Step 1.3.1: Is the return of action.payload a promise?\n\n            if (!isPromise(promise)) {\n              // If not, move on to the next middleware.\n              return next(_extends({}, action, {\n                payload: promise\n              }));\n            }\n          } // Step 1.4: If there's no promise, move on to the next middleware.\n          else {\n            return next(action);\n          } // Step 1b: If there's no payload, move on to the next middleware.\n\n        } else {\n          return next(action);\n        }\n        /**\n         * Instantiate and define constants for:\n         * (1) the action type\n         * (2) the action meta\n         */\n\n\n        var TYPE = action.type;\n        var META = action.meta;\n        /**\n         * Instantiate and define constants for the action type suffixes.\n         * These are appended to the end of the action type.\n         */\n\n        var _PROMISE_TYPE_SUFFIXE = _slicedToArray(PROMISE_TYPE_SUFFIXES, 3),\n            PENDING = _PROMISE_TYPE_SUFFIXE[0],\n            FULFILLED = _PROMISE_TYPE_SUFFIXE[1],\n            REJECTED = _PROMISE_TYPE_SUFFIXE[2];\n        /**\n         * Function: getAction\n         * Description: This function constructs and returns a rejected\n         * or fulfilled action object. The action object is based off the Flux\n         * Standard Action (FSA).\n         *\n         * Given an original action with the type FOO:\n         *\n         * The rejected object model will be:\n         * {\n         *   error: true,\n         *   type: 'FOO_REJECTED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         *\n         * The fulfilled object model will be:\n         * {\n         *   type: 'FOO_FULFILLED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         */\n\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _extends({\n            // Concatenate the type string property.\n            type: [TYPE, isRejected ? REJECTED : FULFILLED].join(PROMISE_TYPE_DELIMITER)\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, META !== undefined ? {\n            meta: META\n          } : {}, isRejected ? {\n            error: true\n          } : {});\n        };\n        /**\n         * Function: handleReject\n         * Calls: getAction to construct the rejected action\n         * Description: This function dispatches the rejected action and returns\n         * the original Error object. Please note the developer is responsible\n         * for constructing and throwing an Error object. The middleware does not\n         * construct any Errors.\n         */\n\n\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n          throw reason;\n        };\n        /**\n         * Function: handleFulfill\n         * Calls: getAction to construct the fullfilled action\n         * Description: This function dispatches the fulfilled action and\n         * returns the success object. The success object should\n         * contain the value and the dispatched action.\n         */\n\n\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n          return {\n            value: value,\n            action: resolvedAction\n          };\n        };\n        /**\n         * First, dispatch the pending action:\n         * This object describes the pending state of a promise and will include\n         * any data (for optimistic updates) and/or meta from the original action.\n         */\n\n\n        next(_extends({\n          // Concatenate the type string.\n          type: [TYPE, PENDING].join(PROMISE_TYPE_DELIMITER)\n        }, data !== undefined ? {\n          payload: data\n        } : {}, META !== undefined ? {\n          meta: META\n        } : {}));\n        /**\n         * Second, dispatch a rejected or fulfilled action and move on to the\n         * next middleware.\n         */\n\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}\nexport default function middleware() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      dispatch = _ref.dispatch;\n\n  if (typeof dispatch === 'function') {\n    return createPromise()({\n      dispatch: dispatch\n    });\n  }\n\n  if (process && process.env && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line no-console\n    console.warn('Redux Promise Middleware: As of version 6.0.0, the middleware library supports both preconfigured and custom configured middleware. To use a custom configuration, use the \"createPromise\" export and call this function with your configuration property. To use a preconfiguration, use the default export. For more help, check the upgrading guide: https://docs.psb.design/redux-promise-middleware/upgrade-guides/v6\\n\\nFor custom configuration:\\nimport { createPromise } from \\'redux-promise-middleware\\';\\nconst promise = createPromise({ types: { fulfilled: \\'success\\' } });\\napplyMiddleware(promise);\\n\\nFor preconfiguration:\\nimport promise from \\'redux-promise-middleware\\';\\napplyMiddleware(promise);\\n    ');\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/home/ale/Software/workspaces/ispyb/py-ispyb-ui/node_modules/redux-promise-middleware/dist/es/index.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_extends","assign","target","arguments","source","key","prototype","hasOwnProperty","call","isPromise","ActionType","Pending","Fulfilled","Rejected","createPromise","config","defaultTypes","PROMISE_TYPE_SUFFIXES","promiseTypeSuffixes","PROMISE_TYPE_DELIMITER","promiseTypeDelimiter","ref","dispatch","action","promise","data","payload","PAYLOAD","TYPE","type","META","meta","_PROMISE_TYPE_SUFFIXE","PENDING","FULFILLED","REJECTED","getAction","newPayload","isRejected","join","error","handleReject","reason","rejectedAction","handleFulfill","resolvedAction","then","middleware","_ref","process","env","NODE_ENV","console","warn"],"mappings":"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","sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport isPromise from './isPromise.js';\n\n/**\n * For TypeScript support: Remember to check and make sure\n * that `index.d.ts` is also up to date with the implementation.\n */\nexport var ActionType = {\n  Pending: 'PENDING',\n  Fulfilled: 'FULFILLED',\n  Rejected: 'REJECTED'\n};\n\n/**\n * Function: createPromise\n * Description: The main createPromise accepts a configuration\n * object and returns the middleware.\n */\nexport function createPromise() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var defaultTypes = [ActionType.Pending, ActionType.Fulfilled, ActionType.Rejected];\n  var PROMISE_TYPE_SUFFIXES = config.promiseTypeSuffixes || defaultTypes;\n  var PROMISE_TYPE_DELIMITER = config.promiseTypeDelimiter || '_';\n\n  return function (ref) {\n    var dispatch = ref.dispatch;\n\n\n    return function (next) {\n      return function (action) {\n\n        /**\n         * Instantiate variables to hold:\n         * (1) the promise\n         * (2) the data for optimistic updates\n         */\n        var promise = void 0;\n        var data = void 0;\n\n        /**\n         * There are multiple ways to dispatch a promise. The first step is to\n         * determine if the promise is defined:\n         * (a) explicitly (action.payload.promise is the promise)\n         * (b) implicitly (action.payload is the promise)\n         * (c) as an async function (returns a promise when called)\n         *\n         * If the promise is not defined in one of these three ways, we don't do\n         * anything and move on to the next middleware in the middleware chain.\n         */\n\n        // Step 1a: Is there a payload?\n        if (action.payload) {\n          var PAYLOAD = action.payload;\n\n          // Step 1.1: Is the promise implicitly defined?\n          if (isPromise(PAYLOAD)) {\n            promise = PAYLOAD;\n          }\n\n          // Step 1.2: Is the promise explicitly defined?\n          else if (isPromise(PAYLOAD.promise)) {\n              promise = PAYLOAD.promise;\n              data = PAYLOAD.data;\n            }\n\n            // Step 1.3: Is the promise returned by an async function?\n            else if (typeof PAYLOAD === 'function' || typeof PAYLOAD.promise === 'function') {\n                promise = PAYLOAD.promise ? PAYLOAD.promise() : PAYLOAD();\n                data = PAYLOAD.promise ? PAYLOAD.data : undefined;\n\n                // Step 1.3.1: Is the return of action.payload a promise?\n                if (!isPromise(promise)) {\n\n                  // If not, move on to the next middleware.\n                  return next(_extends({}, action, {\n                    payload: promise\n                  }));\n                }\n              }\n\n              // Step 1.4: If there's no promise, move on to the next middleware.\n              else {\n                  return next(action);\n                }\n\n          // Step 1b: If there's no payload, move on to the next middleware.\n        } else {\n          return next(action);\n        }\n\n        /**\n         * Instantiate and define constants for:\n         * (1) the action type\n         * (2) the action meta\n         */\n        var TYPE = action.type;\n        var META = action.meta;\n\n        /**\n         * Instantiate and define constants for the action type suffixes.\n         * These are appended to the end of the action type.\n         */\n\n        var _PROMISE_TYPE_SUFFIXE = _slicedToArray(PROMISE_TYPE_SUFFIXES, 3),\n            PENDING = _PROMISE_TYPE_SUFFIXE[0],\n            FULFILLED = _PROMISE_TYPE_SUFFIXE[1],\n            REJECTED = _PROMISE_TYPE_SUFFIXE[2];\n\n        /**\n         * Function: getAction\n         * Description: This function constructs and returns a rejected\n         * or fulfilled action object. The action object is based off the Flux\n         * Standard Action (FSA).\n         *\n         * Given an original action with the type FOO:\n         *\n         * The rejected object model will be:\n         * {\n         *   error: true,\n         *   type: 'FOO_REJECTED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         *\n         * The fulfilled object model will be:\n         * {\n         *   type: 'FOO_FULFILLED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         */\n\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _extends({\n            // Concatenate the type string property.\n            type: [TYPE, isRejected ? REJECTED : FULFILLED].join(PROMISE_TYPE_DELIMITER)\n\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, META !== undefined ? { meta: META } : {}, isRejected ? {\n            error: true\n          } : {});\n        };\n\n        /**\n         * Function: handleReject\n         * Calls: getAction to construct the rejected action\n         * Description: This function dispatches the rejected action and returns\n         * the original Error object. Please note the developer is responsible\n         * for constructing and throwing an Error object. The middleware does not\n         * construct any Errors.\n         */\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n\n          throw reason;\n        };\n\n        /**\n         * Function: handleFulfill\n         * Calls: getAction to construct the fullfilled action\n         * Description: This function dispatches the fulfilled action and\n         * returns the success object. The success object should\n         * contain the value and the dispatched action.\n         */\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n\n          return { value: value, action: resolvedAction };\n        };\n\n        /**\n         * First, dispatch the pending action:\n         * This object describes the pending state of a promise and will include\n         * any data (for optimistic updates) and/or meta from the original action.\n         */\n        next(_extends({\n          // Concatenate the type string.\n          type: [TYPE, PENDING].join(PROMISE_TYPE_DELIMITER)\n\n        }, data !== undefined ? { payload: data } : {}, META !== undefined ? { meta: META } : {}));\n\n        /**\n         * Second, dispatch a rejected or fulfilled action and move on to the\n         * next middleware.\n         */\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}\n\nexport default function middleware() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      dispatch = _ref.dispatch;\n\n  if (typeof dispatch === 'function') {\n    return createPromise()({ dispatch: dispatch });\n  }\n\n  if (process && process.env && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line no-console\n    console.warn('Redux Promise Middleware: As of version 6.0.0, the middleware library supports both preconfigured and custom configured middleware. To use a custom configuration, use the \"createPromise\" export and call this function with your configuration property. To use a preconfiguration, use the default export. For more help, check the upgrading guide: https://docs.psb.design/redux-promise-middleware/upgrade-guides/v6\\n\\nFor custom configuration:\\nimport { createPromise } from \\'redux-promise-middleware\\';\\nconst promise = createPromise({ types: { fulfilled: \\'success\\' } });\\napplyMiddleware(promise);\\n\\nFor preconfiguration:\\nimport promise from \\'redux-promise-middleware\\';\\napplyMiddleware(promise);\\n    ');\n  }\n\n  return null;\n}"]},"metadata":{},"sourceType":"module"}