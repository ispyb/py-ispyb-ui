/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TheAverageTimes = TimeEntry;
export type TotalTime = number;
export type TimeBeforeFirstDataCollection = number;
export type TimeUsedForDataCollections = number;
export type TimeUsedForEnergyScans = number;
export type TotalUsedForXrfScans = number;
export type TotalUsedForRobotSampleActions = number;
export type TimeWaitingForStrategy = number;
export type TotalWaitingForCentring = number;
export type TimeTakenWithFaults = number;
export type TimeRemaining = number;
export type TimeNotUsedByOtherTypes = number;
export type TotalTime1 = number;
export type TimeBeforeFirstDataCollection1 = number;
export type TimeUsedForDataCollections1 = number;
export type TimeUsedForEnergyScans1 = number;
export type TotalUsedForXrfScans1 = number;
export type TotalUsedForRobotSampleActions1 = number;
export type TimeWaitingForStrategy1 = number;
export type TotalWaitingForCentring1 = number;
export type TimeTakenWithFaults1 = number;
export type TimeRemaining1 = number;
export type TimeNotUsedByOtherTypes1 = number;
export type TheSessionId = number;
export type TimesPerSession = SessionTimeEntry[];

export interface Times {
  average: TheAverageTimes;
  sessions: TimesPerSession;
}
export interface TimeEntry {
  duration?: TotalTime;
  startup?: TimeBeforeFirstDataCollection;
  datacollection?: TimeUsedForDataCollections;
  edge?: TimeUsedForEnergyScans;
  xrf?: TotalUsedForXrfScans;
  robot?: TotalUsedForRobotSampleActions;
  strategy?: TimeWaitingForStrategy;
  centring?: TotalWaitingForCentring;
  fault?: TimeTakenWithFaults;
  remaining?: TimeRemaining;
  thinking?: TimeNotUsedByOtherTypes;
}
export interface SessionTimeEntry {
  duration?: TotalTime1;
  startup?: TimeBeforeFirstDataCollection1;
  datacollection?: TimeUsedForDataCollections1;
  edge?: TimeUsedForEnergyScans1;
  xrf?: TotalUsedForXrfScans1;
  robot?: TotalUsedForRobotSampleActions1;
  strategy?: TimeWaitingForStrategy1;
  centring?: TotalWaitingForCentring1;
  fault?: TimeTakenWithFaults1;
  remaining?: TimeRemaining1;
  thinking?: TimeNotUsedByOtherTypes1;
  sessionId: TheSessionId;
}

type Constructor<T = {}> = new (...args: any[]) => T;
export function withTimes<TBase extends Constructor>(Base: TBase) {
  return class WithTimes extends Base {
    average: TheAverageTimes;
    sessions: TimesPerSession;
  }
}
export function withTimeEntry<TBase extends Constructor>(Base: TBase) {
  return class WithTimeEntry extends Base {
    duration?: TotalTime;
    startup?: TimeBeforeFirstDataCollection;
    datacollection?: TimeUsedForDataCollections;
    edge?: TimeUsedForEnergyScans;
    xrf?: TotalUsedForXrfScans;
    robot?: TotalUsedForRobotSampleActions;
    strategy?: TimeWaitingForStrategy;
    centring?: TotalWaitingForCentring;
    fault?: TimeTakenWithFaults;
    remaining?: TimeRemaining;
    thinking?: TimeNotUsedByOtherTypes;
  }
}
export function withSessionTimeEntry<TBase extends Constructor>(Base: TBase) {
  return class WithSessionTimeEntry extends Base {
    duration?: TotalTime1;
    startup?: TimeBeforeFirstDataCollection1;
    datacollection?: TimeUsedForDataCollections1;
    edge?: TimeUsedForEnergyScans1;
    xrf?: TotalUsedForXrfScans1;
    robot?: TotalUsedForRobotSampleActions1;
    strategy?: TimeWaitingForStrategy1;
    centring?: TotalWaitingForCentring1;
    fault?: TimeTakenWithFaults1;
    remaining?: TimeRemaining1;
    thinking?: TimeNotUsedByOtherTypes1;
    sessionId: TheSessionId;
  }
}
